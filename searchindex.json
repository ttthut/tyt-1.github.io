{"categories":[{"title":"Houdini","uri":"https://tyt-1.github.io/categories/houdini/"},{"title":"WebGL","uri":"https://tyt-1.github.io/categories/webgl/"}],"posts":[{"content":"webGL勉強その１\n三角ポリゴン表示まで\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77  import vertexShaderSource from \u0026#39;./shader/shader.vert\u0026#39;; import fragmentShaderSource from \u0026#39;./shader/shader.frag\u0026#39;; const canvas = document.getElementById(\u0026#34;glcanvas\u0026#34;); canvas.width = 500; canvas.height = 500; const gl = canvas.getContext(\u0026#34;webgl\u0026#34;) || canvas.getContext(\u0026#34;experimental-webgl\u0026#34;); // xy −1〜+１のクリップ空間から0 ~ width heightに変換する gl.viewport(0, 0, canvas.width, canvas.height); gl.clearColor(0.0, .5, 1.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT); // faragment Shader生成 const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER); // faragment Shaderのソースを読み込む gl.shaderSource(fragmentShader, fragmentShaderSource); // verterx Shaderコンパイル gl.compileShader(fragmentShader); // verterx Shader生成、読み込み、コンパイル const vertexShader = gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(vertexShader, vertexShaderSource); gl.compileShader(vertexShader); // プログラムオブジェクトとはvarying修飾子を使うために, // 頂点シェーダーからフラグメントシェーダーへのやり取りを管理するものである const program = gl.createProgram(); // プログラムオブジェクトにシェーダーを割り当てる gl.attachShader(program, vertexShader); gl.attachShader(program, fragmentShader); // シェーダをリンクする gl.linkProgram(program); if (!gl.getProgramParameter(program, gl.LINK_STATUS)) { alert(gl.getProgramInfoLog(program)); gl.deleteProgram(program); } // シェーダープログラム指定して起動する gl.useProgram(program); // VBO(頂点バッファ)とは頂点ごとの情報である // 位置以外にも法線や色などを格納することができる // どんな値も持つことができるが,一つの情報毎に一つのVBOが必要である // シェーダのattribute変数へ情報を渡すのがVBOの役割である const vbo = gl.createBuffer(); // bind pointにvboを結合する // 頂点情報のvboを作成するので、ARRAY_BUFFERのbind pointを指定する gl.bindBuffer(gl.ARRAY_BUFFER, vbo); // 頂点を作成 (x,y) const vertexPosition = new Float32Array([ 0.0, 1.0, 1.0, 0.0, -1.0, 0.0, ]); // データをバッファーに入れる gl.bufferData(gl.ARRAY_BUFFER, vertexPosition, gl.STATIC_DRAW); // attribute変数に割り当てられているレジスタのインデックス番号を取得する const positionAttributeLocation = gl.getAttribLocation(program, \u0026#34;a_position\u0026#34;); gl.enableVertexAttribArray(positionAttributeLocation); // vbo(vertexPosition)をvertex Shaderのattributeへ渡す方法を指定する const size = 2; // 2次元のベクトル(x,y)を渡すのでサイズは2である  // vertexShader側の型はvec4だが  // この場合x,yはVBOの値で初期化され、z,wは0, 1で初期化される const type = gl.FLOAT; // 32ビットのfloatとして渡す const normalize = false; // データをnormalizeしない const stride = 0; // size * sizeof(type) const offset = 0; // バッファーの頭から取り始める gl.vertexAttribPointer( positionAttributeLocation, size, type, normalize, stride, offset); gl.drawArrays( gl.TRIANGLES, // 三角ポリゴン  0, // offset  3 // 頂点数 );    ","id":0,"section":"posts","summary":"webGL勉強その１ 三角ポリゴン表示まで 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50","tags":[""],"title":"webGL三角ポリゴンまで","uri":"https://tyt-1.github.io/2019/12/learnwebgl_1/","year":"2019"},{"content":"houdini.env\nhttps://qiita.com/takavfx/items/b58cae65984b15e5ad29\n","id":1,"section":"posts","summary":"houdini.env https://qiita.com/takavfx/items/b58cae65984b15e5ad29","tags":["bookmark"],"title":"Houdiniでの環境変数","uri":"https://tyt-1.github.io/2019/12/houdinipaths/","year":"2019"},{"content":"obj同士のノードをつなげると親子関係になる\n親子関係になると親の位置を子が追随する\n子にKeep Position When Parentingをチェックしてやると距離感を保ったまま親を追随することができる\n追随させて動かしても子の位置情報は変わっていないように見えるが、TransformにあるセレクトボックスからExtract-PreTransformを選ぶと事前変換の値がローカル変換に移行されて確認・編集できる\n追随している状態で親を移動させたい場合はチェックボックスのChild Compensationをチェックすると親のみ移動できる\n","id":2,"section":"posts","summary":"obj同士のノードをつなげると親子関係になる 親子関係になると親の位置を子が追随する 子にKeep Position When Parentingをチェックしてやると距離","tags":["Rigging"],"title":"親子関係と位置","uri":"https://tyt-1.github.io/2019/12/pretransform/","year":"2019"},{"content":"https://www.sidefx.com/learn/collections/cat-quad-rigging/\n","id":3,"section":"posts","summary":"https://www.sidefx.com/learn/collections/cat-quad-rigging/","tags":["Bone","Rigging"],"title":"HoudiniでのBoneやRiggingのチュートリアル","uri":"https://tyt-1.github.io/2019/11/boneandriggingtutorial/","year":"2019"},{"content":"CHOPは音声処理やリギングやアニメーションなどで使われる\nまた、頂点のアニメーションをMotion FXグラフで視覚化することができる\n参考 https://houdini.prisms.xyz/wiki/index.php?title=HoudiniChops\nhttps://www.sidefx.com/ja/docs/houdini/nodes/chop/index.html\n","id":4,"section":"posts","summary":"CHOPは音声処理やリギングやアニメーションなどで使われる また、頂点のアニメーションをMotion FXグラフで視覚化することができる 参考 https://houdini.prisms.xyz/wiki/index.php?title=HoudiniChops https://www.sidefx.com/ja/docs/houdini/nodes/chop/index.html","tags":["CHOP"],"title":"CHOP","uri":"https://tyt-1.github.io/2019/11/chop/","year":"2019"}],"tags":[{"title":"Tags","uri":"https://tyt-1.github.io/tags/"},{"title":"Bone","uri":"https://tyt-1.github.io/tags/bone/"},{"title":"bookmark","uri":"https://tyt-1.github.io/tags/bookmark/"},{"title":"CHOP","uri":"https://tyt-1.github.io/tags/chop/"},{"title":"Rigging","uri":"https://tyt-1.github.io/tags/rigging/"}]}